<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>class</title>
</head>
<body>

</body>
<script>
    class Animal { // class 定义一个"类"
        constructor() { //  构造方法  在这里面定义的属性和方法是实例对象自己的  相反之外的就是所有实例对象可以共享的
           this.name = "王楠平"
        }
        says() {
            console.log("属性为："+this.name);
        }
    }
    const animal = new Animal();
    animal.says(); // 属性为：王楠平
    class Cat extends Animal { // Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。
        constructor() {
            super()
            // super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
            this.name = 'cat'
        }
    }
    let cat = new Cat();
    cat.says(); // 属性为：cat
    // ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。


    // 如何设置class 私有方法

    const bar = Symbol('bar');
    const snaf = Symbol('snaf');

    class My{
        
        // 公有方法
        foo(baz){
            this[bar](baz);
        }

        // 私有方法  // 第三发无法访问 
        [bar](baz){
            return this[snaf] = baz;
        }
    }

  
</script>
</html>